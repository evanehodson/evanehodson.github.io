<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sommet Innovations — GradeSense</title>
  <link rel="stylesheet" href="style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- MapLibre -->
  <script src="https://unpkg.com/maplibre-gl@^5.15.0/dist/maplibre-gl.js"></script>
  <link href="https://unpkg.com/maplibre-gl@^5.15.0/dist/maplibre-gl.css" rel="stylesheet" />
  <!-- Turf.js for bearing calculations -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    #map { width: 100%; height: 50vh; margin-bottom: 2rem; border: 1px solid #222; position: relative; }
    #elevation { width: 100%; height: 25vh; margin-bottom: 2rem; }
    nav { margin-bottom: 2rem; display: flex; gap: 1rem; }
    
    /* Controls overlay */
    .map-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(0,0,0,0.8);
      padding: 15px 25px;
      border-radius: 8px;
      display: flex;
      gap: 15px;
      align-items: center;
    }
    
    .map-controls button {
      background: #4a8a4a;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
    }
    
    .map-controls button:hover {
      background: #5a9a5a;
    }
    
    .map-controls button.active {
      background: #ff4444;
    }
    
    .map-controls .info {
      color: #ccc;
      font-size: 13px;
    }
  </style>
</head>
<body>
<header>
  <h1>Sommet Innovations</h1>
  <p>Building tools for endurance athletes and ultrarunners</p>
  <nav>
    <a href="index.html">Home</a>
    <a href="devlog.html">Devlog</a>
  </nav>
</header>
<section class="about">
  <p><strong>Sommet Innovations</strong> creates data-driven tools to optimize endurance training. Our flagship project, <strong>GradeSense</strong>, is a terrain-aware ultramarathon pacing and finishing-time prediction model. Explore the map below to see a demo of GradeSense in action.</p>
</section>
<article>
  <div id="map">
    <div class="map-controls">
      <button id="toggleFly">Start Flythrough</button>
      <div class="info">
        <span id="progressText">Ready</span>
      </div>
    </div>
  </div>
  <canvas id="elevation"></canvas>
</article>
<footer>
  <p>© 2026 Sommet Innovations.</p>
</footer>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const geojsonUrl = 'GeoJSON/Javelina_100.geojson';
  let coordinates = [];
  let elevations = [];
  let distances = [];
  let map;
  let isFlying = false;
  let flyAnimationId = null;

  fetch(geojsonUrl)
    .then(resp => resp.json())
    .then(data => {
      coordinates = data.features[0].geometry.coordinates;
      elevations = coordinates.map(c => c[2] || 0);

      let dist = 0;
      distances.push(0);
      for (let i = 1; i < coordinates.length; i++) {
        const [lon1, lat1] = coordinates[i-1];
        const [lon2, lat2] = coordinates[i];
        const R = 6371000;
        const φ1 = lat1 * Math.PI/180, φ2 = lat2 * Math.PI/180;
        const Δφ = (lat2-lat1)*Math.PI/180, Δλ = (lon2-lon1)*Math.PI/180;
        const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        dist += R * c;
        distances.push(dist);
      }

      plotElevation();
      initMap();
    })
    .catch(err => console.error('Error loading GeoJSON:', err));

  function plotElevation() {
    const ctx = document.getElementById('elevation').getContext('2d');
    new Chart(ctx, {
      type: 'line',
      data: {
        labels: distances.map(d => (d/1000).toFixed(2)),
        datasets: [{
          label: 'Elevation (m)',
          data: elevations,
          borderColor: '#4a8a4a',
          borderWidth: 2,
          fill: false,
          tension: 0.2
        }]
      },
      options: {
        responsive: true,
        plugins: { legend: { display: false } },
        scales: {
          x: { title: { display: true, text: 'Distance (km)' }, ticks: { color: '#ccc' } },
          y: { title: { display: true, text: 'Elevation (m)' }, ticks: { color: '#ccc' } }
        }
      }
    });
  }

  function initMap() {
    if (!coordinates.length) return;

    map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          'osm': {
            type: 'raster',
            tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
            tileSize: 256,
            attribution: '© OpenStreetMap contributors'
          }
        },
        layers: [{
          id: 'osm',
          type: 'raster',
          source: 'osm',
          minzoom: 0,
          maxzoom: 22
        }]
      },
      center: coordinates[0],
      zoom: 14,
      pitch: 60,
      bearing: 0,
      maxBounds: [
        [-111.85, 33.62],
        [-111.62, 33.77]
      ]
    });

    map.on('load', () => {
      // Add Terrain-RGB DEM source
      map.addSource('dem', {
        type: 'raster-dem',
        tiles: ['tiles/Javelina_100/{z}/{x}/{y}.png'],
        tileSize: 256,
        minzoom: 12,
        maxzoom: 16,
        encoding: 'mapbox',
        bounds: [-111.808257, 33.649035, -111.671469, 33.740898]
      });

      // Set terrain AFTER adding hillshade
      map.setTerrain({
        source: 'dem',
        exaggeration: 1.2
      });

      // Add hillshade layer on top of everything for visibility
      map.addLayer({
        id: 'hillshade',
        type: 'hillshade',
        source: 'dem',
        paint: {
          'hillshade-exaggeration': 0.25,
          'hillshade-shadow-color': '#000000',
          'hillshade-highlight-color': '#ffffff',
          'hillshade-accent-color': '#999999'
        }
      });

      // Add the track as a thick, bright line
      map.addSource('track', {
        type: 'geojson',
        data: { type: "Feature", geometry: { type: "LineString", coordinates } }
      });

      // Add track outline (white) for visibility
      map.addLayer({
        id: 'track-outline',
        type: 'line',
        source: 'track',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 
          'line-color': '#ffffff', 
          'line-width': 8,
          'line-opacity': 0.8
        }
      });

      // Add track line (red) on top
      map.addLayer({
        id: 'track-line',
        type: 'line',
        source: 'track',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 
          'line-color': '#ff0000', 
          'line-width': 5
        }
      });

      // Setup flythrough controls
      setupFlythroughControls();
    });

    map.on('error', (e) => {
      // Silently handle missing tile errors
      if (e.error && e.error.status === 404) return;
      console.error('Map error:', e.error);
    });
  }

  function setupFlythroughControls() {
    const toggleBtn = document.getElementById('toggleFly');
    const progressText = document.getElementById('progressText');

    // Smooth and simplify the coordinate path
    const smoothedCoords = smoothPath(coordinates, 30); // Average every 30 points for slower motion

    let idx = 0;
    const pointsPerFrame = 1; // Move 1 smoothed point per frame
    const frameDuration = 450; // Much slower - 150ms per frame
    let currentBearing = 0; // Track bearing for smooth transitions

    function smoothPath(coords, windowSize) {
      const smoothed = [];
      for (let i = 0; i < coords.length; i += windowSize) {
        const window = coords.slice(i, Math.min(i + windowSize, coords.length));
        const avgLon = window.reduce((sum, c) => sum + c[0], 0) / window.length;
        const avgLat = window.reduce((sum, c) => sum + c[1], 0) / window.length;
        smoothed.push([avgLon, avgLat]);
      }
      return smoothed;
    }

    function startFlythrough() {
      if (isFlying) {
        stopFlythrough();
        return;
      }

      isFlying = true;
      toggleBtn.textContent = 'Stop Flythrough';
      toggleBtn.classList.add('active');
      idx = 0;

      function animate() {
        if (!isFlying || idx >= smoothedCoords.length - 1) {
          stopFlythrough();
          return;
        }

        const [lon, lat] = smoothedCoords[idx];
        const nextIdx = Math.min(idx + 3, smoothedCoords.length - 1);
        const [lonNext, latNext] = smoothedCoords[nextIdx];

        // Calculate bearing and smooth it
        const targetBearing = turf.bearing(
          turf.point([lon, lat]),
          turf.point([lonNext, latNext])
        );
        
        // Smooth bearing transitions (avoid jumps)
        let bearingDiff = targetBearing - currentBearing;
        if (bearingDiff > 180) bearingDiff -= 360;
        if (bearingDiff < -180) bearingDiff += 360;
        currentBearing += bearingDiff * 0.3; // Smooth transition

        // Update progress
        const progress = ((idx / smoothedCoords.length) * 100).toFixed(1);
        progressText.textContent = `Progress: ${progress}%`;

        // Smooth camera movement with higher altitude and moderate pitch
        map.easeTo({
          center: [lon, lat],
          bearing: currentBearing,
          pitch: 62, // Moderate pitch for better view
          zoom: 15.8, // Pulled back slightly for smoother terrain
          duration: frameDuration,
          easing: t => t * (2 - t) // Ease-out for smoother motion
        });

        idx += pointsPerFrame;
        flyAnimationId = setTimeout(animate, frameDuration);
      }

      animate();
    }

    function stopFlythrough() {
      isFlying = false;
      toggleBtn.textContent = 'Start Flythrough';
      toggleBtn.classList.remove('active');
      progressText.textContent = 'Paused';
      if (flyAnimationId) {
        clearTimeout(flyAnimationId);
        flyAnimationId = null;
      }
    }

    toggleBtn.addEventListener('click', startFlythrough);

    // Allow spacebar to toggle
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        startFlythrough();
      }
    });
  }
});
</script>
</body>
</html>